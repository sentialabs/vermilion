## Some informtion regarding Antlr4

Here are some further resourcs regarding Atlr4

https://tomassetti.me/antlr-mega-tutorial/

https://github.com/antlr/grammars-v4

https://alexecollins.com/antlr4-and-maven-tutorial/



## Lexer and grammar
The actual definition of a language syntax usually comes in two parts: 
- the *lexer* rules define which combinations of characters when taken together as a unit have some meaning in the language (usually such a construct is called a *token*).
- the *grammar* rules define what combinations of tokens are valid.

Note that neither lexical nor grammatical rules say what a particular combination of characters is supposed to *mean*. To give meaning, the creator of the language must add actions to the detected rules.

To give an example, lexical rules may define that 'a' is an identifer, '2' is a constant and '+' is the plus operator. A grammar rule maye determine that "a+2" is a valid syntax. When  this expression is parsed, at some point a callback function is called for the plus operator, the identifier 'a' and the constant '2'. 

It is however you, the creator of the language, who has to extract the value of 'a' from somewhere, convert the constant '2' to another value, add these together and return the result.

## Adding meanningful action to detected grammar rules
With antlr4, you write the lexer and grammar rules into two files in a format that the tool can understand, run the antlr4 generator, and this will output a set of Java source files that together with the antlr4 runtime library form a parser for the language.

When the parser parses some input code the result is a *parse tree*. When you subsequently *walk* this tree with one of the Parser objects that were also generated by antlr4, the various methods in the Parser object are called for the various nodes in the tree. The information at what point in the tree we find ourselves is contained in a *contex* object.

Your job as a creator of the language, apart from writing the lexer and grammar for the generating process, is to extend one of the generated Parser types and fill in what should happen for various nodes in the parse three. You extract information from the context provided by the tree walker, and together with the knowledge that you are in a certain node type (because of the callback method you are overriding) you have all you need to perform a meaningful action such finding values for 'a' and '2' (from the context) and adding these (you are in the 'plus' callback method).

## Details of the lexer
Since in this case we are using an island grammar, the NUMBERCALCOPEN token is the marker that switches the parser between normal text content and scripting syntax mode. This is the meaning of the ```pushMode(NUMBERCALC)``` for that token. As you can see, the NUMBERCALCCLOSE token has a corresponding  ```popMode``` to switch back to parsing in  HTML mode.

The definition of the STATTICTEXT token effectively says "any sequence of characters up to an '${*' marker should be considered STATICTEXT (in other words, not embedded script). The actual definition of the STATICTEXT token is a bit more complicated because we want to allow for a '$' that  is not followed by a '{' and also for a '${' that is not followed by a '\*'. Only when all three characters are encountered consecutively this counts as the start of an embedded expression.

The tokens inside of the number calculation markers are not very surprising for the most  part. Any single characters that has a meaning in our syntax is given a name whicj will be used when defining grammar rules. The DIGIT and ALFA fragments are used in the definition of CONSTANT IDENTIFIER.

The lexical rule for CONSTANT says: a constant is a sequence of at least one DIGIT, possibly folllowed by a DOT and another sequence of at leas one DIGIT.

The rule for IDENTIFIER allows for concatenating names with dots in between, where a name is allowed to begin with a letter or an underscore, but not with a number. Note that nothing is defined about identifiers being case sensitive or not.  This is in fact a detail that will be settled when we will be using identifiers to obtain a value.

Finally the WS token definition says "if you encounter any space, tab, carriage return or newline character do not pass this token on to the parser".

## Details of the grammar
The "options" line tells antlr4 that this grammar expects tokens as defined by the lexer named "NumberLexer"

Then the grammar  starts defining syntax rules. 

At the outermost level, every sequence of tokens that is presented to the parser is matched against the "document" rule.

The document rule says that we can expect a sequence of things that are either "text" or "calculation". The sequence is allowed to be totally empty (the definitions are interpreted by antlr4 along the lines of regular expressions).

A "text" thing is simply a STATICTEXT token. The 'statictext' following the hash sign '#' is not actually a comment but tells antlr4 how we would like the method for this rule to be named in the generated Java code.

A "calculation" thing is an "expression" between an opening and closing token, and we want to name the  coresponding method "result".

The definition for the "expression" rule says that an expression can be one of five different sequences of tokens. Also notice that some of the definitions refer recursively to "expression". This has to do with the recursive descent aspect of parsing code.  In this way you can parse for instance ```((2+3) * 4)``` by allowing "2+3" to be an expression, while "(2+3)" is another expression which in turn is part of still another expression of which "*" and "4" are the other parts.
